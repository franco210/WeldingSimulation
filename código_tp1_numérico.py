# -*- coding: utf-8 -*-
"""Código TP1 Numérico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ejLHKWYnJwQvvc2kd_S5Sk9MVMiMQxHb

# Librerias
"""

import pandas as pd
import numpy as np
from tqdm import tqdm
import matplotlib.pyplot as plt

tolerancia = 0.01
digitos = 6 # ¿no sé?

pd.options.display.float_format = '{:.5f}'.format

from google.colab import drive
drive.mount('/content/drive')

"""# **Seleccione la matriz con la que desea trabajar**

**360 50**
"""

A = np.array(pd.read_csv('/content/drive/MyDrive/Numérico/TP1/A_360_050.csv',header=None))
b = np.array(pd.read_csv('/content/drive/MyDrive/Numérico/TP1/b_360_050.csv',header=None))

radio = 50

# armado de listas.
franja_lejos_derecha = []
for i in range(1,radio-1):
  franja_lejos_derecha.append(A[i,i+radio])

franja_lejos_izquierda = []
for i in range(1,radio-1):
  franja_lejos_izquierda.append(A[radio+i,i])

diagonal = []
for i in range(1,radio-1):
  diagonal.append(A[i,i])

franja_cerca_derecha = []
for i in range(1,radio-1):
  franja_cerca_derecha.append(A[i,i+1])

franja_cerca_izquierda = []
for i in range(1,radio-1):
  franja_cerca_izquierda.append(A[i,i-1])

"""**180 20**"""

A = np.array(pd.read_csv('/content/drive/MyDrive/Numérico/TP1/A_180_020.csv',header=None))
b = np.array(pd.read_csv('/content/drive/MyDrive/Numérico/TP1/b_180_020.csv',header=None))

radio = 20

# armado de listas.
franja_lejos_derecha = []
for i in range(1,radio-1):
  franja_lejos_derecha.append(A[i,i+radio])

franja_lejos_izquierda = []
for i in range(1,radio-1):
  franja_lejos_izquierda.append(A[radio+i,i])

diagonal = []
for i in range(1,radio-1):
  diagonal.append(A[i,i])

franja_cerca_derecha = []
for i in range(1,radio-1):
  franja_cerca_derecha.append(A[i,i+1])

franja_cerca_izquierda = []
for i in range(1,radio-1):
  franja_cerca_izquierda.append(A[i,i-1])

"""**90 10**"""

A = np.array(pd.read_csv('/content/drive/MyDrive/Numérico/TP1/A_090_010.csv',header=None))
b = np.array(pd.read_csv('/content/drive/MyDrive/Numérico/TP1/b_090_010.csv',header=None))

radio = 10

# armado de listas.
franja_lejos_derecha = []
for i in range(1,radio-1):
  franja_lejos_derecha.append(A[i,i+radio])

franja_lejos_izquierda = []
for i in range(1,radio-1):
  franja_lejos_izquierda.append(A[radio+i,i])

diagonal = []
for i in range(1,radio-1):
  diagonal.append(A[i,i])

franja_cerca_derecha = []
for i in range(1,radio-1):
  franja_cerca_derecha.append(A[i,i+1])

franja_cerca_izquierda = []
for i in range(1,radio-1):
  franja_cerca_izquierda.append(A[i,i-1])

"""# Metodo **SOR**"""

def calculador(w,semilla):
  fila = 0
  sum = 0
  x = semilla.copy()
  sum_total = 0

  while(fila < len(A)):
    i=0
    while (i<radio and fila < len(A)):
      sum=0
      if(i==0): sum_total = b[fila]
      if(i==radio-1): sum_total = b[fila]
      if(i>0 and i<radio-1):
        sum = -((franja_cerca_derecha[i-1] * x[fila+1]) + (franja_cerca_izquierda[i-1] * x[fila-1])) # los coeficientes de al lado de la diagional      
        if(fila < radio): sum = sum - ((franja_lejos_derecha[i-1] * x[fila+radio]) + (franja_lejos_derecha[i-1] * x[len(A)-radio+i])) #el coeficiente más lejos a la derecha de la diagonal
        if(fila > radio and fila < len(A) - radio): sum = sum- (franja_lejos_izquierda[i-1]*x[fila-radio] + franja_lejos_derecha[i-1] * x[fila+radio]) # coeficientes más lejos de la diagonal.
        if(fila > len(A) - radio and fila<len(A)-1): sum = sum - (franja_lejos_izquierda[i-1]*x[fila-radio] + franja_lejos_izquierda[i-1]*x[i])
        sum_total = sum/diagonal[i-1]

      total = (sum_total * w) + ((1-w)*x[fila])
      x[fila] = total

      fila +=1
      i +=1
  return x.copy()

def solver_SOR_iteraciones(w):
  x_anterior = np.zeros(len(A))
  x_siguiente = np.zeros(len(A))
  
  iteraciones = 0
  error = 1000
  tolerancia = 0.00001


  while(iteraciones < 500 and error > tolerancia):
    x_siguiente = calculador(w,x_anterior.copy())

    error=(np.max(abs(x_siguiente-x_anterior)) / np.max(abs(x_siguiente)))
    
    iteraciones += 1
    x_anterior = x_siguiente.copy()

  #print(iteraciones)
  return iteraciones

"""## Calculo para el $W_{optimo}$, este devuelve la cantidad de interaciones necesarías para los valores de w que van desde 1 a 2, con salto de 0.1"""

resultados = []
w_lista = np.round(list(np.linspace(1.1, 1.9, 9)),1)
i = 0

for i in tqdm(range(len(w_lista))):
  m_iteraciones = solver_SOR_iteraciones(w_lista[i])
  resultados.append(m_iteraciones)
resultados

"""Grafico de $W_{optimo}$"""

plt.figure(figsize=(9,6.3),dpi=96)
plt.plot(w_lista, resultados,marker="o")
plt.xlabel("w", fontsize=15, verticalalignment="top")
plt.ylabel("Número de iteraciones", fontsize=15, verticalalignment="bottom")
plt.show()

"""## **Aplicando el metodo**:"""

def solver_SOR_tabla(w):
  x_anterior = np.zeros(len(A))
  x_siguiente = np.zeros(len(A))
  
  iteraciones = 0
  error = 1000
  tolerancia = 0.00001
  print(iteraciones,x_siguiente[:5])
  while(iteraciones < 500 and error > tolerancia):
    x_siguiente = calculador(w,x_anterior.copy())

    error=(np.max(abs(x_siguiente-x_anterior)) / np.max(abs(x_siguiente)))
    
    iteraciones += 1
    x_anterior = x_siguiente.copy()
    print(iteraciones,x_siguiente[:5],error)
  return x_siguiente.copy()
  #return iteraciones

"""Poner aquí el valor del $w_{optimo}$ y obtendremos una tabla con los resultados de las iteraciones"""

resultado = solver_SOR_tabla(1.8)

"""# Metodo **G-S**"""

def calculadorGS(semilla):
  fila = 0
  sum = 0
  x = semilla.copy()
  sum_total = 0

  while(fila < len(A)):
    i=0
    while (i<radio and fila < len(A)):
      sum=0
      if(i==0): sum_total = np.round(b[fila],7)
      if(i==radio-1): sum_total = np.round(b[fila],7)
      if(i>0 and i<radio-1):
        sum = -((franja_cerca_derecha[i-1] * x[fila+1]) + (franja_cerca_izquierda[i-1] * x[fila-1])) # los coeficientes de al lado de la diagional      
        if(fila < radio): sum = sum - ((franja_lejos_derecha[i-1] * x[fila+radio]) + (franja_lejos_derecha[i-1] * x[len(A)-radio+i])) #el coeficiente más lejos a la derecha de la diagonal
        if(fila > radio and fila < len(A) - radio): sum = sum- (franja_lejos_izquierda[i-1]*x[fila-radio] + franja_lejos_derecha[i-1] * x[fila+radio]) # coeficientes más lejos de la diagonal.
        if(fila > len(A) - radio and fila<len(A)-1): sum = sum - (franja_lejos_izquierda[i-1]*x[fila-radio] + franja_lejos_izquierda[i-1]*x[i])
        sum_total = sum/diagonal[i-1]

      total = np.round(sum_total,7)
      x[fila] = np.round(total,7)

      fila +=1
      i +=1
  return x.copy()

def solver_GS():
  x_anterior = np.zeros(len(A))
  x_siguiente = np.zeros(len(A))
  
  iteraciones = 0
  error = 1000
  tolerancia = 0.00001

  while(iteraciones < 500 and error > tolerancia):
    x_siguiente = calculadorGS(x_anterior.copy())

    error=(np.max(abs(x_siguiente-x_anterior)) / np.max(abs(x_siguiente)))
    
    iteraciones += 1
    x_anterior = x_siguiente.copy()

  return x_siguiente.copy()

x = solver_GS()

"""# Errores, Velocidad de convergencía y Gráficos

Antes de ejecutar este codigo, recordar antes ejecutar las funciones calculador que estan dentro de la ficha método SOR y GS

## Error Metodo **SOR**
"""

def solver_SOR_errores(w): 

  x_anterior = np.zeros(len(A))
  x_siguiente = np.zeros(len(A))
  error_anterior = []
  error_siguiente = []
  iteraciones = 0
  error = 1000
  tolerancia = 0.00001
  error_grafico = 100 

  while(iteraciones < 500 and error > tolerancia):
    x_siguiente = calculador(w,x_anterior.copy())
    
    error_anterior.append(error_grafico)
    
    error=(np.max(abs(x_siguiente-x_anterior)) / np.max(abs(x_siguiente)))
    
    error_grafico = (np.max(abs(x_siguiente-x_anterior)))

    error_siguiente.append(error_grafico)

    iteraciones += 1
    x_anterior = x_siguiente.copy()
  return [error_anterior.copy(),error_siguiente.copy()]

"""Recordar colocar el $w$ con el que se esta trabajando"""

errores_SOR = solver_SOR_errores(1.5)

"""### **Orden de convergencia**

"""

(np.log(errores_SOR[1][-1]/errores_SOR[1][-2]))/(np.log(errores_SOR[1][-2]/errores_SOR[1][-3]))

"""### Las graficas:

Gráfico de errores en función del error anterior para el método **SOR**
"""

plt.figure(figsize=(10,8.3),dpi=96)
plt.plot(errores_SOR[0][0:],errores_SOR[1][0:],marker="o", color="red", label="SOR")
plt.grid()
plt.legend(loc='upper left')

plt.show()

"""Gráfico de errores en función del ln de los errores en función al ln del error anterior para el método **SOR**"""

plt.figure(figsize=(10,8.3),dpi=96)
plt.plot(np.log(errores_SOR[0][0:]),np.log(errores_SOR[1][0:]),marker="o", color="red", label="SOR")
plt.grid()
plt.legend(loc='upper left')
plt.title("Matriz ni:90 nj:10")
plt.xlabel("ln(error[k])", fontsize=15, verticalalignment="top")
plt.ylabel("ln(error[k+1])", fontsize=15, verticalalignment="bottom")

plt.show()

"""Gráfico de error tomando el siguiente por iteración para el método **SOR**"""

plt.figure(figsize=(10,8.3),dpi=96)
plt.plot(np.array(range(len(errores_SOR[1][1:]))),errores_SOR[1][1:],marker="o", color="red", label="SOR")
plt.grid()
plt.legend(loc='upper left')

plt.show()

"""## Error metodo **G-S**"""

def solver_GS_errores():

  x_anterior = np.zeros(len(A))
  x_siguiente = np.zeros(len(A))
  error_anterior = []
  error_siguiente = []
  iteraciones = 0
  error = 1000
  tolerancia = 0.00001
  error_grafico = 100 

  while(iteraciones < 500 and error > tolerancia):
    x_siguiente = calculadorGS(x_anterior.copy())
    
    error_anterior.append(error_grafico)
    
    error=(np.max(abs(x_siguiente-x_anterior)) / np.max(abs(x_siguiente)))
    
    error_grafico = (np.max(abs(x_siguiente-x_anterior)))

    error_siguiente.append(error_grafico)

    iteraciones += 1
    x_anterior = x_siguiente.copy()
  return [error_anterior.copy(),error_siguiente.copy()]

errores_GS = solver_GS_errores()

"""### **Orden de convergencia**"""

np.log(errores_GS[1][-1]/errores_GS[1][-2])/np.log(errores_GS[1][-2]/errores_GS[1][-3])

"""### Las graficas:

Gráfico de errores en función del error anterior para el método **G-S**
"""

plt.figure(figsize=(10,8.3),dpi=96)
plt.plot(errores_GS[0][0:],errores_GS[1][0:],marker="o", color="orange", label="Gauss Seidel")
plt.grid()
plt.legend(loc='upper left')
plt.show()

"""Gráfico de errores en función del ln de los errores en función al ln del error anterior para el método **GS**"""

plt.figure(figsize=(10,8.3),dpi=96)
plt.plot(np.log(errores_GS[0][0:]),np.log(errores_GS[1][0:]),marker="o", color="orange", label="Gauss Seidel")
plt.grid()
plt.legend(loc='upper left')
plt.title("Matriz ni:90 nj:10")
plt.xlabel("ln(error[k])", fontsize=15, verticalalignment="top")
plt.ylabel("ln(error[k+1])", fontsize=15, verticalalignment="bottom")
plt.show()

"""Gráfico de error tomando el siguiente por iteración para el método **SOR**"""

plt.figure(figsize=(10,8.3),dpi=96)
plt.plot(np.array(range(len(errores_GS[1][1:]))),errores_GS[1][1:],marker="o", color="orange", label="Gauss Seidel")
plt.grid()
plt.legend(loc='upper left')
plt.show()

plt.figure(figsize=(10,8.3),dpi=96)
plt.plot(np.log(errores_GS[0][0:]),np.log(errores_GS[1][0:]),marker="o", color="orange", label="Gauss Seidel")
plt.plot(np.log(errores_SOR[0][0:]),np.log(errores_SOR[1][0:]),marker="o", color="red", label="SOR")
plt.grid()
plt.legend(loc='upper left')
plt.title("Matriz ni:360 nj:50")
plt.xlabel("ln(error[k])", fontsize=15, verticalalignment="top")
plt.ylabel("ln(error[k+1])", fontsize=15, verticalalignment="bottom")
plt.xlim(0,8)
plt.ylim(0,8)
plt.show()